var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ethers } from "ethers-alice";
import Address from "../Address";
import EthereumConfig from "../config/EthereumConfig";
import { ZERO_ADDRESS } from "../constants";
import ERC20 from "../contracts/ERC20";
import Gateway from "../contracts/Gateway";
import { toBigNumber } from "../utils/big-number-utils";
import { getLogs } from "../utils/ethers-utils";
class EthereumChain {
    constructor(privateKey, testnet = false) {
        this.getPrivateKey = () => this.privateKey;
        this.getProvider = () => this.provider;
        this.getAddress = () => this.address;
        this.getSigner = () => this.wallet;
        this.getGateway = () => {
            return new Gateway(this.config.gateway.address, this.getSigner());
        };
        this.createERC20 = (asset) => {
            return new ERC20(asset.ethereumAddress.toLocalAddressString(), this.getSigner());
        };
        this.updateAssetBalancesAsync = (assets, updateBalance) => {
            return Promise.all(assets.map(asset => {
                const promise = asset.ethereumAddress.isZero()
                    ? this.balanceOfETHAsync()
                    : this.balanceOfERC20Async(asset);
                return promise.then(balance => updateBalance(asset.ethereumAddress, balance));
            }));
        };
        this.transferERC20Async = (asset, to, amount) => {
            const erc20 = this.createERC20(asset);
            return erc20.transfer(to, amount);
        };
        this.balanceOfETHAsync = () => {
            return this.provider.getBalance(this.address.toLocalAddressString());
        };
        this.transferETHAsync = (to, amount) => {
            return this.getSigner().sendTransaction({ to, value: amount.toHexString() });
        };
        this.approveETHAsync = (spender, amount) => {
            return Promise.resolve({
                to: ZERO_ADDRESS,
                from: this.address.toLocalAddressString(),
                confirmations: 0,
                nonce: 0,
                gasLimit: toBigNumber(0),
                gasPrice: toBigNumber(0),
                data: "0x",
                value: toBigNumber(0),
                chainId: Number(this.config.chainId),
                wait: () => Promise.resolve({
                    byzantium: true
                })
            });
        };
        this.balanceOfERC20Async = (asset) => {
            const erc20 = this.createERC20(asset);
            return erc20.balanceOf(this.address.toLocalAddressString());
        };
        this.approveERC20Async = (asset, spender, amount) => {
            const erc20 = this.createERC20(asset);
            return erc20.approve(spender, amount);
        };
        /**
         * Deposit ETH to Gateway. The `amount` is transferred to `LoomChain` after 10 blocks of confirmations.
         *
         * @link https://loomx.io/developers/en/transfer-gateway.html
         *
         * @param amount
         */
        this.depositETHAsync = (amount) => {
            const gateway = this.getGateway();
            return this.getSigner().sendTransaction({ to: gateway.address, value: amount });
        };
        /**
         * Deposit ERC20 `asset` to Gateway. The `amount` is transferred to `LoomChain` after 10 blocks of confirmations.
         *
         * @link https://loomx.io/developers/en/transfer-gateway.html
         *
         * @param asset
         * @param amount
         */
        this.depositERC20Async = (asset, amount) => {
            const gateway = this.getGateway();
            return gateway.depositERC20(amount, asset.ethereumAddress.toLocalAddressString());
        };
        /**
         * Withdraw `amount` of ETH from Gateway by submitting `signature`.
         * The signature is valid if generated by calling `LoomChain.withdrawETHAsync()`.
         *
         * @link https://loomx.io/developers/en/transfer-gateway.html
         *
         * @param amount
         * @param signature
         */
        this.withdrawETHAsync = (amount, signature) => {
            const gateway = this.getGateway();
            return gateway.withdrawETH(amount, signature);
        };
        /**
         * Withdraw `amount` of ERC20 `asset` from Gateway by submitting `signature`.
         * The signature is valid if generated by calling `LoomChain.withdrawETHAsync()`.
         *
         * @link https://loomx.io/developers/en/transfer-gateway.html
         *
         * @param asset
         * @param amount
         * @param signature
         */
        this.withdrawERC20Async = (asset, amount, signature) => {
            const gateway = this.getGateway();
            return gateway.withdrawERC20(amount, signature, asset.ethereumAddress.toLocalAddressString());
        };
        /**
         * Get a list of `ETHReceived` logs.
         * Every time `depositETHAsync` is called, an `ETHReceived` event is logged.
         *
         * @returns an array of `ETHReceived`
         */
        this.getETHReceivedLogsAsync = (fromBlock = 0, toBlock = 0) => __awaiter(this, void 0, void 0, function* () {
            const provider = this.getProvider();
            const gateway = this.getGateway();
            if (fromBlock === 0) {
                const transaction = yield provider.getTransaction(this.config.gateway.transactionHash);
                fromBlock = Number(transaction.blockNumber || 0);
            }
            if (toBlock === 0) {
                const blockNumber = yield provider.getBlockNumber();
                toBlock = Number(blockNumber);
            }
            const event = gateway.interface.events.ETHReceived;
            const logs = yield getLogs(provider, {
                address: this.config.gateway.address,
                topics: [event.topic],
                fromBlock,
                toBlock
            });
            return logs
                .sort((l1, l2) => (l2.blockNumber || 0) - (l1.blockNumber || 0))
                .map(log => (Object.assign({ log }, event.decode(log.data))))
                .filter(data => Address.createEthereumAddress(data.from || ZERO_ADDRESS).equals(this.getAddress()));
        });
        /**
         * Get a list of `ERC20Received` logs.
         * Every time `depositERC20Async` is called, an `ERC20Received` event is logged.
         *
         * @param asset
         *
         * @returns an array of `ERC20Received`
         */
        this.getERC20ReceivedLogsAsync = (asset, fromBlock = 0, toBlock = 0) => __awaiter(this, void 0, void 0, function* () {
            const provider = this.getProvider();
            const gateway = this.getGateway();
            if (fromBlock === 0) {
                const transaction = yield provider.getTransaction(this.config.gateway.transactionHash);
                fromBlock = Number(transaction.blockNumber || 0);
            }
            if (toBlock === 0) {
                const blockNumber = yield provider.getBlockNumber();
                toBlock = Number(blockNumber);
            }
            const event = gateway.interface.events.ERC20Received;
            const logs = yield getLogs(provider, {
                address: this.config.gateway.address,
                topics: [event.topic],
                fromBlock,
                toBlock
            });
            return logs
                .sort((l1, l2) => (l2.blockNumber || 0) - (l1.blockNumber || 0))
                .map(log => (Object.assign({ log }, event.decode(log.data))))
                .filter(data => Address.createEthereumAddress(data.from || ZERO_ADDRESS).equals(this.getAddress()) &&
                Address.createEthereumAddress(data.contractAddress || ZERO_ADDRESS).equals(asset.ethereumAddress));
        });
        /**
         * Get a list of `ETHWithdrawn` logs.
         * Every time `withdrawETHAsync` is called, an `ETHWithdrawn` event is logged.
         *
         * @returns an array of `ETHWithdrawn`
         */
        this.getETHWithdrawnLogsAsync = (fromBlock = 0, toBlock = 0) => this.getTokenWithdrawnLogsAsync(Address.createEthereumAddress(ZERO_ADDRESS), fromBlock, toBlock);
        /**
         * Get a list of `ERC20Withdrawn` logs.
         * Every time `withdrawERC20Async` is called, an `ERC20Withdrawn` event is logged.
         *
         * @returns an array of `ERC20Withdrawn`
         */
        this.getERC20WithdrawnLogsAsync = (asset, fromBlock = 0, toBlock = 0) => this.getTokenWithdrawnLogsAsync(asset.ethereumAddress, fromBlock, toBlock);
        /**
         * Get your nonce for withdrawal. It increments every time you execute a withdrawal.
         */
        this.getWithdrawalNonceAsync = () => __awaiter(this, void 0, void 0, function* () {
            const gateway = this.getGateway();
            return yield gateway.nonces(this.getAddress().toLocalAddressString());
        });
        this.getTokenWithdrawnLogsAsync = (assetAddress, fromBlock = 0, toBlock = 0) => __awaiter(this, void 0, void 0, function* () {
            const provider = this.getProvider();
            const gateway = this.getGateway();
            if (fromBlock === 0) {
                const transaction = yield provider.getTransaction(this.config.gateway.transactionHash);
                fromBlock = Number(transaction.blockNumber || 0);
            }
            if (toBlock === 0) {
                const blockNumber = yield provider.getBlockNumber();
                toBlock = Number(blockNumber);
            }
            const event = gateway.interface.events.TokenWithdrawn;
            const logs = yield getLogs(provider, {
                address: this.config.gateway.address,
                topics: [event.topic, event.encodeTopics([this.getAddress().toLocalAddressString()])],
                fromBlock,
                toBlock
            });
            return logs
                .sort((l1, l2) => (l2.blockNumber || 0) - (l1.blockNumber || 0))
                .map(log => (Object.assign({ log }, event.decode(log.data))))
                .filter(data => Address.createEthereumAddress(data.contractAddress).equals(assetAddress));
        });
        this.config = EthereumConfig.create(testnet);
        this.privateKey = privateKey;
        this.init(privateKey);
    }
    init(privateKey) {
        this.provider = new ethers.providers.InfuraProvider(this.config.networkName);
        this.provider.on("end", () => this.init(privateKey));
        this.provider.on("error", () => { });
        this.wallet = new ethers.Wallet(privateKey, this.provider);
        this.address = Address.createEthereumAddress(this.wallet.address);
    }
}
export default EthereumChain;
//# sourceMappingURL=EthereumChain.js.map